# 重要文件

###  组织结构
```json
{
    "copyLibFiles": {
        "script": "scripts/copyLibFiles.ts",
        "dir" : "/src/resources/libFiles/"
    },
    "createCompilerVersions":{
        "script": "scripts/copyLibFiles.ts",
        "dir" : "/src/compiler/compilerVersions.ts"
    },
    "createFactoryCode":{
        "script": "scripts/createFactoryCode.ts",
        "dir" : "/src/resources/factoryCode/"
    },
    "createPublicApiInfo":{
        "script": "scripts/createPublicApiInfo.ts",
        "dir" : "/src/resources/publicApiInfo/"
    }
}

```

## scripts/

### analyzers/TsAnalyzer.ts
```ts
export class TsAnalyzer {
    //保存的符号信息
    private readonly tsSymbol: Symbol;

    constructor(typeScriptModuleName: string) {
        const project = new Project({ compilerOptions: { strictNullChecks: true } });
        const tsSourceFile = project.addExistingSourceFile(`node_modules/${typeScriptModuleName}/lib/typescript.d.ts`);
        //读取符号信息
        this.tsSymbol = tsSourceFile.getNamespaceOrThrow("ts").getSymbolOrThrow();
    }

    //读取Symbol
    getSymbolProperties() {
        return this.getPropertiesForExport("Symbol");
    }
    //读取Type
    getTypeProperties() {
        return this.getPropertiesForExport("Type");
    }
    //读取Signature
    getSignatureProperties() {
        return this.getPropertiesForExport("Signature");
    }
    // 获取Node
    getNodePropertiesBySyntaxKind() {
        const result = new Map<string, Set<string>>();
        const exports = this.tsSymbol.getExports();

        for (const [kindText, node] of getNodes()) {
            const properties = getResultPropertiesSetForKind(kindText);
            for (const prop of node.getDeclaredType().getProperties()) {
                if (isAllowedProperty(prop))
                    properties.add(prop.getName());
            }
        }

        // add the comment ranges in as well
        result.set("SingleLineCommentTrivia", this.getPropertiesForExport("CommentRange"));
        result.set("MultiLineCommentTrivia", this.getPropertiesForExport("CommentRange"));

        return result;
    }
    // 读取属性信息
    private getPropertiesForExport(name: string) {
        const exports = this.tsSymbol.getExports();
        const symbolType = this.tsSymbol.getExportOrThrow(name).getDeclaredType();
        const properties = new Set<string>();

        for (const symbol of getSymbolSymbols()) {
            for (const prop of symbol.getDeclaredType().getProperties()) {
                if (isAllowedProperty(prop))
                    properties.add(prop.getName());
            }
        }

        return properties;
    }
}
```
### getCompilerVersions
> 获取支持的compiler版本
```ts
export function getCompilerVersions() {
    //package.dependencies.typescript-**;
    const fileData = JSON.parse(fs.readFileSync("./package.json", "utf-8"));
    const dependencies = fileData["dependencies"];
    const keyRegEx = /^typescript(-[0-9]+\.[0-9]+\.[0-9]+)?$/;
    const versionRegEx = /[0-9]+\.[0-9]+\.[0-9]+/;
    const versions: { version: string; name: string; }[] = [];

    //typescript-next处理
    for (const key of Object.keys(dependencies)) {
        if (key === "typescript-next") {
            const tsNextInfo = JSON.parse(fs.readFileSync("./node_modules/typescript-next/package.json", "utf-8"));
            versions.push({ version: `@next (${tsNextInfo.version})`, name: key });
            continue;
        }

        if (!keyRegEx.test(key))
            continue;
        const matches = versionRegEx.exec(dependencies[key])!;
        versions.push({ version: matches[0], name: key });
    }

    //排序
    return versions.sort((a, b) => {
        if (a.version.startsWith("@next"))
            return 1;
        if (b.version.startsWith("@next"))
            return -1;
        return a.version > b.version ? -1 : 1;
    });
}
```

### copyLibFiles
> 读取lib文件
```ts
const versions = getCompilerVersions();

//更新resources/libFiles目录文件
glob("./src/resources/libFiles/**/*.ts", (err, filesToDelete) => {
    //删除文件
    for (const filePath of filesToDelete)
        fs.unlinkSync(filePath);

    // lib目录
    const libFilesDir = "./src/resources/libFiles/";
    // 多版本lib生成
    for (const version of versions) {
        glob(`./node_modules/${version.name}/lib/lib*.d.ts`, (err, filePaths) => {
            const libVersionDir = libFilesDir + version.name + "/";
            if (!fs.existsSync(libVersionDir))
                fs.mkdirSync(libVersionDir);

            for (const filePath of filePaths) {
                const newFilePath = libVersionDir + path.basename(filePath, ".d.ts") + ".ts";
                const fileText = fs.readFileSync(filePath).toString().replace(/\`/g, "\\`");
                fs.writeFileSync(newFilePath, `export default {\n`
                    + `    fileName: \`/${path.basename(filePath)}\`,\n`
                    + `    text: \`${fileText.replace(/\r?\n/g, "\n")}\`\n`
                    + `};`);
            }

            fs.writeFileSync(
                libVersionDir + "index.ts",
                filePaths
                    .map(p => path.basename(p, ".d.ts"))
                    .map((p, i) => "export { default as export" + i + " } from \"./" + p + "\";").join("\n") + "\n"
            );
        }
    }
}

```
### createCompilerVersions
```ts
const versions = getCompilerVersions();

const project = new Project({
    manipulationSettings: {
        newLineKind: os.EOL === "\n" ? NewLineKind.LineFeed : NewLineKind.CarriageReturnLineFeed
    }
});

//清空文件
const compilerVersionsFile = project.addExistingSourceFile("./src/compiler/compilerVersions.ts");
compilerVersionsFile.removeText();

//生成代码
compilerVersionsFile.addStatements([writer => {
    writer.writeLine("// dprint-ignore-file")
        .writeLine("/* Automatically maintained from package.json. Do not edit! */")
        .blankLine();
}, {
    kind: StructureKind.ImportDeclaration,
    namedImports: ["Node", "CompilerApi"],
    moduleSpecifier: "./CompilerApi"
}, {
    kind: StructureKind.ImportDeclaration,
    namedImports: ["assertNever"],
    moduleSpecifier: "../utils"
}, {
    kind: StructureKind.TypeAlias,
    isExported: true,
    name: "CompilerVersions",
    type: versions.map(v => `"${v.version}"`).join(" | ")
}, {
    kind: StructureKind.TypeAlias,
    isExported: true,
    name: "CompilerPackageNames",
    type: versions.map(v => `"${v.name}"`).join(" | ")
}, {
    kind: StructureKind.VariableStatement,
    isExported: true,
    declarationKind: VariableDeclarationKind.Const,
    declarations: [{
        name: "compilerVersionCollection",
        initializer: writer => {
            writer.write("[").newLine();
            writer.indent(() => {
                for (let i = 0; i < versions.length; i++) {
                    const version = versions[i];
                    writer.write(`{ version: "${version.version}", packageName: "${version.name}" }`);
                    if (i < versions.length - 1)
                        writer.write(",");
                    writer.newLine();
                }
            });
            writer.write("]");
        },
        type: "{ version: CompilerVersions; packageName: CompilerPackageNames; }[]"
    }]
}, {
    kind: StructureKind.Function,
    isExported: true,
    isAsync: true,
    name: "importCompilerApi",
    parameters: [{ name: "packageName", type: "CompilerPackageNames" }],
    statements: writer => {
        writer.writeLine("// these explicit import statements are required to get webpack to include these modules");
        writer.write("switch (packageName)").block(() => {
            for (const version of versions) {
                writer.writeLine(`case "${version.name}":`);
                writer.indent(() => {
                    writer.writeLine(`return await import("${version.name}");`);
                });
            }
            writer.writeLine(`default:`);
            writer.indent(() => {
                writer.writeLine("return assertNever(packageName, `Not implemented version: ${packageName}`);");
            });
        });
    }
}, {
    kind: StructureKind.Function,
    isExported: true,
    isAsync: true,
    name: "importLibFiles",
    parameters: [{ name: "packageName", type: "CompilerPackageNames" }],
    statements: writer => {
        writer.writeLine("// these explicit import statements are required to get webpack to include these modules");
        writer.write("switch (packageName)").block(() => {
            for (const version of versions) {
                writer.writeLine(`case "${version.name}":`);
                writer.indent(() => {
                    writer.writeLine(`return await import("../resources/libFiles/${version.name}/index");`);
                });
            }
            writer.writeLine(`default:`);
            writer.indent(() => {
                writer.writeLine("return assertNever(packageName, `Not implemented version: ${packageName}`);");
            });
        });
    }
}, {
    kind: StructureKind.TypeAlias,
    isExported: true,
    name: "FactoryCodeGenerator",
    type: "(ts: CompilerApi, node: Node) => string"
}, {
    kind: StructureKind.Function,
    isExported: true,
    isAsync: true,
    name: "getGenerateFactoryCodeFunction",
    parameters: [{ name: "packageName", type: "CompilerPackageNames" }],
    returnType: "Promise<FactoryCodeGenerator>",
    statements: writer => {
        writer.writeLine("// these explicit import statements are required to get webpack to include these modules");
        writer.write("switch (packageName)").block(() => {
            for (const version of versions) {
                writer.writeLine(`case "${version.name}":`);
                writer.indent(() => {
                    writer.writeLine(`return (await import("../resources/factoryCode/${version.name}")).generateFactoryCode as any;`);
                });
            }
            writer.writeLine(`default:`);
            writer.indent(() => {
                writer.writeLine("return assertNever(packageName, `Not implemented version: ${packageName}`);");
            });
        });
    }
}, {
    kind: StructureKind.Interface,
    isExported: true,
    name: "PublicApiInfo",
    properties: [{
        name: "nodePropertiesBySyntaxKind",
        type: "Map<string, Set<string>>"
    }, {
        name: "symbolProperties",
        type: "Set<string>"
    }, {
        name: "typeProperties",
        type: "Set<string>"
    }, {
        name: "signatureProperties",
        type: "Set<string>"
    }]
}, {
    kind: StructureKind.Function,
    isExported: true,
    isAsync: true,
    name: "getPublicApiInfo",
    returnType: "Promise<PublicApiInfo>",
    parameters: [{ name: "packageName", type: "CompilerPackageNames" }],
    statements: writer => {
        writer.writeLine("// these explicit import statements are required to get webpack to include these modules");
        writer.write("switch (packageName)").block(() => {
            for (const version of versions) {
                writer.writeLine(`case "${version.name}":`);
                writer.indent(() => {
                    writer.writeLine(`return (await import("../resources/publicApiInfo/${version.name}"));`);
                });
            }
            writer.writeLine(`default:`);
            writer.indent(() => {
                writer.writeLine("return assertNever(packageName, `Not implemented version: ${packageName}`);");
            });
        });
    }
}]);

//保存文件
compilerVersionsFile.save();
```

### createFactoryCode
```ts
const versions = getCompilerVersions();
//factoryCode
const factoryCodeDir = "./src/resources/factoryCode/";
//编译生成
glob(`${factoryCodeDir}/*.ts`, (err, filesToDelete) => {
    for (const filePath of filesToDelete)
        fs.unlinkSync(filePath);

    for (const version of versions) {
        const code = generateCode(version.name);
        const newFilePath = factoryCodeDir + `${version.name}.ts`;
        fs.writeFileSync(newFilePath, `${code.replace(/\r?\n/g, "\n")}`);
    }
});
```

### createPublicApiInfo
```ts
const versions = getCompilerVersions();
const publicApiInfoDir = "./src/resources/publicApiInfo/";

glob(`${publicApiInfoDir}/*.ts`, (err, filesToDelete) => {
    for (const filePath of filesToDelete)
        fs.unlinkSync(filePath);

    for (const version of versions) {
        const code = getCode(version.name);
        const newFilePath = publicApiInfoDir + `${version.name}.ts`;
        fs.writeFileSync(newFilePath, code);
    }
});

//生成代码
function getCode(versionName: string) {
    const analyzer = new TsAnalyzer(versionName);
    const writer = new CodeBlockWriter();

    // node properties
    writer.writeLine("export const nodePropertiesBySyntaxKind = new Map([");
    writer.indent(() => {
        for (const [syntaxKindName, properties] of analyzer.getNodePropertiesBySyntaxKind()) {
            writer.write(`["${syntaxKindName}", new Set([`);
            for (const prop of properties)
                writer.quote(prop).write(",");
            writer.write("])],").newLine();
        }
    });
    writer.writeLine("]);").newLine();

    // others
    writeForProperties("symbolProperties", analyzer.getSymbolProperties());
    writeForProperties("typeProperties", analyzer.getTypeProperties());
    writeForProperties("signatureProperties", analyzer.getSignatureProperties());

    return writer.toString();

    function writeForProperties(name: string, properties: Set<string>) {
        writer.writeLine(`export const ${name} = new Set([`);
        for (const prop of properties)
            writer.quote(prop).write(",");
        writer.writeLine("])");
    }
}
```
## src/resources
> typescript各个版本的api
### libFiles
> lib的所有文件

### factoryCode
> ts代码生成器
```ts
//typescript.ts

export function generateFactoryCode(
    ts: typeof import("typescript"), 
    initialNode: import("typescript").Node
) {
    const writer = new CodeBlockWriter({ newLine: "\n", indentNumberOfSpaces: 2 });
    const syntaxKindToName = createSyntaxKindToNameMap();

    if (ts.isSourceFile(initialNode)) {
        writer.write("[");
        if (initialNode.statements.length > 0) {
            writer.indent(() => {
                for (let i = 0; i < initialNode.statements.length; i++) {
                    const statement = initialNode.statements[i];
                    if (i > 0)
                        writer.write(",").newLine();
                    writeNodeText(statement);
                }
            }).newLine();
        }
        writer.write("];");
    }
    else {
        writeNodeText(initialNode);
    }

    writer.newLineIfLastNot();

    return writer.toString();

    // writeNodeText
    function writeNodeText(node: import("typescript").Node) {
    }

    // 
    function createNumericLiteral(node: import("typescript").NumericLiteral) {
        writer.write("ts.createNumericLiteral(");
        writer.quote(node.text.toString())
        writer.write(")");
    }
    function createBigIntLiteral(node: import("typescript").BigIntLiteral) {
        writer.write("ts.createBigIntLiteral(");
        writer.quote(node.text.toString())
        writer.write(")");
    }
    ...
}
```

### publicApiInfo
```ts
//typescript.ts
export const nodePropertiesBySyntaxKind = new Map([]);
export const symbolProperties = new Set([]);
export const typeProperties = new Set([])
export const signatureProperties = new Set([])
```
## src/compiler

